<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Hugo Thomas</title><link>https://thmhugo.github.io/post/</link><description>Recent content in Posts on Hugo Thomas</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 20 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://thmhugo.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>State-of-the-art review</title><link>https://thmhugo.github.io/post/review-graph-sparsification/</link><pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate><guid>https://thmhugo.github.io/post/review-graph-sparsification/</guid><description><![CDATA[ This report presents a review of a paper written by ( Citation: Apers&#32;&amp;&#32;Wolf,&#32;2019 Apers,&#32; S.&#32;&amp;&#32;Wolf,&#32; R. &#32; (2019). &#32;Quantum Speedup for Graph Sparsification, Cut Approximation and Laplacian Solving. https://doi.org/10.48550/ARXIV.1911.07306 ) in which a new quantum algorithm for graph sparsification relying on nearly linear classical algorithms is introduced, leading to quantum speedups for several problems such as extremal cuts and Laplacian solving.
Introduction $$\textit{&quot; Graphs are nice [&hellip;], but sparse graphs are nicer.]]></description><content:encoded><![CDATA[ <p>This report presents a review of a paper written by 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Simon"><span itemprop="familyName">Apers</span></span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Ronald"><span itemprop="familyName">Wolf</span></span>,&#32;<span itemprop="datePublished">2019</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Apers</span>,&#32;
    <meta itemprop="givenName" content="Simon" />
    S.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Wolf</span>,&#32;
    <meta itemprop="givenName" content="Ronald" />
    R.</span>
  &#32;
    (<span itemprop="datePublished">2019</span>).
  &#32;<span itemprop="name">Quantum Speedup for Graph Sparsification, Cut Approximation and Laplacian Solving</span>.
  <a href="https://doi.org/10.48550/ARXIV.1911.07306"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.48550/ARXIV.1911.07306</a></span>




</span></span>)</span>
 in which a new quantum algorithm for graph sparsification relying on nearly
linear classical algorithms is introduced, leading to quantum speedups for
several problems such as extremal cuts and Laplacian solving.</p>
<h1 id="introduction">Introduction</h1>
<p>$$\textit{&quot; Graphs are nice [&hellip;], but sparse graphs are nicer. &ldquo;}$$</p>
<p>Graphs are a very common data structure in many areas of computer
science, such as optimization and networks. Many practical problems can
indeed be reduced to graph problems, and as such are of interest to
computer scientists. Recent works, such as that by Chen <em>et al.</em>,
yielded a near-linear time classical algorithm for the exact
maximum-cost flow problem 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Li"><span itemprop="familyName">Chen</span></span>,&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Rasmus"><span itemprop="familyName">Kyng</span></span>
                  <em>&amp; al.</em>,&#32;<span itemprop="datePublished">2022</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Chen</span>,&#32;
    <meta itemprop="givenName" content="Li" />
    L.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Kyng</span>,&#32;
    <meta itemprop="givenName" content="Rasmus" />
    R.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Liu</span>,&#32;
    <meta itemprop="givenName" content="Yang P." />
    Y.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Peng</span>,&#32;
    <meta itemprop="givenName" content="Richard" />
    R.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Gutenberg</span>,&#32;
    <meta itemprop="givenName" content="Maximilian Probst" />
    M.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Sachdeva</span>,&#32;
    <meta itemprop="givenName" content="Sushant" />
    S.</span>
  &#32;
    (<span itemprop="datePublished">2022</span>).
  &#32;<span itemprop="name">Maximum Flow and Minimum-Cost Flow in Almost-Linear Time</span>.
  <a href="https://doi.org/10.48550/ARXIV.2203.00671"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.48550/ARXIV.2203.00671</a></span>




</span></span>)</span>
. It is nevertheless
possible to get an even better speedup by considering approximate
algorithms. The paper contribution is the creation of a quantum
algorithm for $\varepsilon$-spectral sparsification of graphs in time
$\tilde{O}(\frac{\sqrt{nm}}{\varepsilon})$, proving by the way the lower
bound of their algorithm. Taking into account the algorithm of Chen <em>et
al.</em>, it results in an algorithm generalizable to most graph problems.</p>
<h2 id="graphs">Graphs</h2>
<p>Let $G = (V, E, \omega)$ be a weighted graph, where $V$ is a set of
vertices, $E$ a set of edges, and
$\omega : V \times V \rightarrow \mathbb{R}$ a weight function, with
$|V| = n$ and $|E| = m \leq \binom{n}{2}$. $G$ is said to be undirected
if for all $i,j \in V$ then $(i,j) \in E$ implies $(j,i) \in E$.</p>
<div class="figure">
<img src="https://thmhugo.github.io/resources/graph.svg" alt="Example of undirected weighted graph">
<p class="caption" id="graph-example">Example of undirected weighted graph</p>
</div>
<p>The access to the graph are done via the <em>adjacency list</em>.</p>
<h2 id="graph-laplacian">Graph Laplacian</h2>
<p>Let $G = (V, E, \omega)$ be a weighted graph, the Laplacian of $G$ is an
$n
\times n$ matrix defined as $$L_G = D - A$$ where $D$ is the degree
matrix and $A$ is the adjacency matrix, defined such that
$(D)_{ii} = \sum_j \omega(i,j)$ and $(A)_{ij} = \omega(i,j)$. The graph
shown in <span class="autoref">graph-example</span> has the following adjacency and
degree matrices $$A = \begin{pmatrix}
0 &amp; 1 &amp; 2 &amp; 1 \\\
1 &amp; 0 &amp; 2 &amp; 2 \\\
2 &amp; 2 &amp; 0 &amp; 0 \\\
1 &amp; 2 &amp; 0 &amp; 0
\end{pmatrix} \text{,}
\quad
D = \begin{pmatrix}
4 &amp; 0 &amp; 0 &amp; 0 \\\
0 &amp; 5 &amp; 0 &amp; 0 \\\
0 &amp; 0 &amp; 4 &amp; 0 \\\
0 &amp; 0 &amp; 0 &amp; 3
\end{pmatrix} \text{,}$$ which yield the Laplacian
$$L = \begin{pmatrix}
4 &amp; -1 &amp; -2 &amp; -1 \\\
-1 &amp; 5 &amp; -2 &amp; -2 \\\
-2 &amp; -2 &amp; 4 &amp; 0 \\\
-1 &amp; -2 &amp; 0 &amp; 3
\end{pmatrix} \text{.}$$</p>
<p>An interesting property of the Laplacian that arises from those
definitions is that $L_G$ is invertible if and only if the graph $G$ is
connected. Equivalently, the Laplacian of a graph can be expressed in
terms of a weighted sum of its edges Laplacian:
$$L_Q = \sum_{(i,j)\in E} \omega(i,j)L_{(i,j)}$$ where $L_{(i,j)}$
denotes the Laplacian of the edge $(i,j)$, defined as
$$L_{(i,j)} = (\mathbf e_i - \mathbf e_j)(\mathbf e_i - \mathbf e_j)^T$$
$\mathbf e_i$ is a unit vector with a 1 in coordinate $i$ and zeros
everywhere else. One can remark that $L_{(i,j)}$ is a very sparse
matrix, with only 4 nonzero entries.</p>
<p>The Laplacian is a positive semidefinite matrix i.e. the eigenvalues of
the Laplacian are non-negative.</p>
<p>The pseudo inverse of a Laplacian $L$ denoted $L^+$, is such that
$LL^+L = L$ and $L^+LL^+ = L^+$.</p>
<h2 id="quadratic-forms-of-a-laplacian">Quadratic forms of a Laplacian</h2>
<p>The quadratic form of a Laplacian has a number of nice properties, and
can be used to calculate quantities associated to the graph. All
quadratic forms of a Laplacian can be expressed, by linearity of the
sum, in terms of a weighted sum of its edges Laplacian:
$$\begin{aligned}
\chi^T L_G \chi
&amp; = \sum_{(i,j)\in E} \omega(i,j)\chi^T L_{(i,j)}\chi\\\
&amp; = \sum_{(i,j)\in E} \omega(i,j)(\chi(i) - \chi(j))^2
\end{aligned}$$</p>
<p>An interesting example, showing how quadratic forms underlie graphs
properties, is that if $\chi_s$ is an indicator vector on
$S \subseteq V$, the quadratic form $\chi_s L_G \chi_s$ is equal to the
value of the cut $(S, S^c)$.</p>
<h2 id="spectral-sparsification">Spectral Sparsification</h2>
<p>Spectral sparsification of graphs aims to reduce the number of edges,
while keeping an approximation of interesting quantities i.e.,
approximately preserving all quadratic forms.</p>
<h4 id="definition">Definition</h4>
<h5 id="varepsilon-sparsifier">$\varepsilon$-sparsifier</h5>
<p>H is an $\varepsilon$-sparsifier of G if and only if for all $\chi \in \mathbb{R}^n$n
the following holds:
$$\chi^T L_H \chi= (1 \pm \varepsilon)\chi^T L_G \chi \ .$$</p>
<p>Using the pseudo-inverse of the Laplacian, this definition can be
equivalently formulated as
$\chi L_H^+ = (1 \pm O(\varepsilon)) \chi L_G^+\chi$. It is also
possible to define an $\varepsilon$-spectral sparsifier taking into
account the positive semidefinite property of the Laplacian, such that
$(1-\varepsilon) L_G \preccurlyeq
L_h \preccurlyeq (1+\varepsilon) L_G$, where $\preccurlyeq$ denotes the
partial ordering on symmetric matrices. The three above definitions are
equivalent and one should use one or the other depending on the context.</p>
<h4 id="theorem">Theorem</h4>
<h5 id="graph-sparsifier">Graph Sparsifier</h5>
<p>Every graph $G$ has an
$\varepsilon$-spectral sparsifier $H$ with a number of edges in
$\tilde{O}(\frac{n}{\varepsilon^2})$. Moreover, $H$ can be found in time
$\tilde{O}(m)$.</p>
<p>One should note that this is relevant only when
$\varepsilon\leq \sqrt\frac{n}{m}$</p>
<p>The existence of such $\varepsilon$-spectral sparsifier was proved by 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Daniel A."><span itemprop="familyName">Spielman</span></span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Shang-Hua"><span itemprop="familyName">Teng</span></span>,&#32;<span itemprop="datePublished">2011</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Spielman</span>,&#32;
    <meta itemprop="givenName" content="Daniel A." />
    D.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Teng</span>,&#32;
    <meta itemprop="givenName" content="Shang-Hua" />
    S.</span>
  &#32;
    (<span itemprop="datePublished">2011</span>).
  &#32;<span itemprop="name">Spectral Sparsification of Graphs</span>.<i>
    <span itemprop="about">SIAM Journal on Computing</span>,&#32;40(4)</i>.&#32;<span itemprop="pagination">981–1025</span>.
  <a href="https://doi.org/10.1137/08074489X"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1137/08074489X</a></span>




</span></span>)</span>
. Additional work of 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Joshua"><span itemprop="familyName">Batson</span></span>,&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Daniel A."><span itemprop="familyName">Spielman</span></span>
                  <em>&amp; al.</em>,&#32;<span itemprop="datePublished">2012</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Batson</span>,&#32;
    <meta itemprop="givenName" content="Joshua" />
    J.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Spielman</span>,&#32;
    <meta itemprop="givenName" content="Daniel A." />
    D.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Srivastava</span>,&#32;
    <meta itemprop="givenName" content="Nikhil" />
    N.</span>
  &#32;
    (<span itemprop="datePublished">2012</span>).
  &#32;<span itemprop="name">Twice-Ramanujan Sparsifiers</span>.<i>
    <span itemprop="about">SIAM Journal on Computing</span>,&#32;41(6)</i>.&#32;<span itemprop="pagination">1704–1721</span>.
  <a href="https://doi.org/10.1137/090772873"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1137/090772873</a></span>




</span></span>)</span>
 reduced the lower bound on the number of edges
in the sparsifier to $O(\frac{n}{\varepsilon^2})$.</p>
<h1 id="seq:classical_sparsification">Classical Sparsification Algorithm</h1>
<p>The classical algorithm for graph sparsification is based on edge
sampling, where each edge is added to the sparsifier according to a
fixed probability distribution.</p>
<p>In order to be sure $L_H$ effectively approximates $L_G$, the choice of each
$p_e$ cannot be done at random. A nearly-linear classical sparsification
algorithm was introduced by 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Daniel A."><span itemprop="familyName">Spielman</span></span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Nikhil"><span itemprop="familyName">Srivastava</span></span>,&#32;<span itemprop="datePublished">2011</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Spielman</span>,&#32;
    <meta itemprop="givenName" content="Daniel A." />
    D.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Srivastava</span>,&#32;
    <meta itemprop="givenName" content="Nikhil" />
    N.</span>
  &#32;
    (<span itemprop="datePublished">2011</span>).
  &#32;<span itemprop="name">Graph Sparsification by Effective Resistances</span>.<i>
    <span itemprop="about">SIAM Journal on Computing</span>,&#32;40(6)</i>.&#32;<span itemprop="pagination">1913–1926</span>.
  <a href="https://doi.org/10.1137/080734029"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1137/080734029</a></span>




</span></span>)</span>
, by approximating
effective resistance between any two edges in the graph efficiently, and thus
introducing a way to correctly sampling the edges.</p>
<h2 id="effective-resistance">Effective resistance</h2>
<p>In the case of unweighted graphs, the effective resistance of an edge
can be related to the connectivity of the graph: edges belonging to
strong components have a low effective resistance, and vertex cut (whose
removal renders G disconnected) tends to have a high effective
resistance.</p>
<p>The effective resistance of the bold edge is roughly $r_e = 1$, while
the effective resistance of the other is $r_e \in O(\frac{1}{n})$.
Spielman and Srivastava associated then the probability for an edge to
be kept while constructing the sparsifier proportionally to
$r_e \omega_e$.</p>
<p>In a graph $G=(V,E)$ the effective resistance $r_e$ of an edge
$e=(u,v)$, with $u,v$ two nodes, can be expressed with the quadratic
form $$\label{eq:effective-resistance}
R_{u,v} = (\chi_u - \chi_v)^TL_G^+(\chi_u - \chi_v) \text{ ,}$$ where
$\chi_i$ is the $i^{th}$ vector of the canonical basis.





<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Daniel A."><span itemprop="familyName">Spielman</span></span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Nikhil"><span itemprop="familyName">Srivastava</span></span>,&#32;<span itemprop="datePublished">2011</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Spielman</span>,&#32;
    <meta itemprop="givenName" content="Daniel A." />
    D.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Srivastava</span>,&#32;
    <meta itemprop="givenName" content="Nikhil" />
    N.</span>
  &#32;
    (<span itemprop="datePublished">2011</span>).
  &#32;<span itemprop="name">Graph Sparsification by Effective Resistances</span>.<i>
    <span itemprop="about">SIAM Journal on Computing</span>,&#32;40(6)</i>.&#32;<span itemprop="pagination">1913–1926</span>.
  <a href="https://doi.org/10.1137/080734029"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1137/080734029</a></span>




</span></span>)</span>
</p>
<h2 id="graph-spanner">Graph spanner</h2>
<p>The <em>distance</em> between two nodes $u$ and $v$ with respect to $G$ is
defined as:
$$\delta_G(u,v) = \min_{u\rightarrow v} \sum_{i} \omega(p_{i}, p_{i+1})^{-1},$$
which is consistent with the previous definition of effective resistance
of an edge, where ${ u\rightarrow v}$ is the set of all paths from $u$
to $v$ in $G$, each element $u\rightarrow v = {p_0, \cdots, p_k}$ is a
set of vertices of $V$. A spanner $H$ of a graph $G$ is a subgraph of
$G$ with fewer edges, where a trade-off is made between the number of
edges and the stretching of distances.</p>
<h4 id="definition-1">Definition</h4>
<h5 id="graph-spanner-1">Graph spanner</h5>
<p>An $(\alpha,\beta)$-spanner of the graph $G=(V,E)$ is a subgraph $H = (V,E_H)$
with $E_H \subseteq E$, such that $\forall u, v \in V$, $$\delta_G(u,v) \leq
\delta_H(u,v) \leq \alpha\delta_G(u,v) + \beta.$$</p>
<p>This definition holds for weighted graphs, in which case the weight of
the kept edges stay unchanged. In the following only multiplicative
spanners are considered, i.e. $\beta = 0$ and $\alpha = 2 \log n$,
namely, $2\log
n$-spanners. Furthermore, key objects of the algorithm for graph
$\varepsilon$-spectral sparsification described below are $r$-packings
spanners.</p>
<h4 id="rPackingSpanner">Definition</h4>
<h5 id="r-packing-spanner">$r$-packing spanner</h5>
<p>Let $G$ be a graph, an $r$-packings spanner of $G$ is an ordered set $H=(H_1,
\cdots, H_r)$ of $r$ edge-disjoint subgraphs of $G$ such that $H_i$ is a spanner
for the graph $G - \bigcup_{j=1}^{i-1} H_j$.</p>
<p>Koutis and Xu proposed the following algorithm 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Ioannis"><span itemprop="familyName">Koutis</span></span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Shen Chen"><span itemprop="familyName">Xu</span></span>,&#32;<span itemprop="datePublished">2016</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Koutis</span>,&#32;
    <meta itemprop="givenName" content="Ioannis" />
    I.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Xu</span>,&#32;
    <meta itemprop="givenName" content="Shen Chen" />
    S.</span>
  &#32;
    (<span itemprop="datePublished">2016</span>).
  &#32;<span itemprop="name">Simple Parallel and Distributed Algorithms for Spectral Graph Sparsification</span>.<i>
    <span itemprop="about">ACM Transactions on Parallel Computing</span>,&#32;3(2)</i>.&#32;<span itemprop="pagination">1–14</span>.
  <a href="https://doi.org/10.1145/2948062"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1145/2948062</a></span>




</span></span>)</span>
,
using the effective resistance of each edge as exhibited by Spielman and
Srivastava to construct $t$-packings spanner of the input graph:</p>
<pre class="algorithm" id='cs'>
\begin{algorithm}
\caption{\textbf{ClassicallySparsify}($G,\epsilon$)}
\begin{algorithmic}
\STATE \textit{construct an $O(\frac{\log n}{\epsilon ^2})$-packing spanner $H$ of $G$}
\STATE $\tilde{G} \leftarrow H $
\FORALL{$e \notin H$}
    \STATE \textit{w.p. $\frac{1}{4}$ add e to $\tilde{G}$, with weight $4\omega_e$}
\ENDFOR
\RETURN $\tilde{G}$
\end{algorithmic}
\end{algorithm}
</pre>
<p>and provided the following theorem:</p>
<h4 id="thmClassicalSparsifier">Theorem</h4>
<h5 id="classical-sparsifier">Classical sparsifier</h5>
<p>The output $\tilde{G}$ of <strong>ClassicallySparsify</strong> on inputs $G$ and
$\varepsilon$ satisfies with probability $1 - \frac{1}{n^2}$ $$(1 - \varepsilon)
L_G \preccurlyeq L_{\tilde{G}} \preccurlyeq (1 + \varepsilon) L_G$$ Moreover,
the expected number of edges in $\tilde{G}$ is at most
$\tilde{O}(\frac{n}{\varepsilon^2} + \frac{m}{2})$.</p>
<p>The proof of the theorem of <a href="https://thmhugo.github.io">classical sparsification</a> ensures that the output of
<strong>ClassicallySparsify</strong> is an $\varepsilon$-spectral sparsifier. A single
iteration of the above procedure divides the number of edges in the output graph
by roughly two. Hence, repeating $t \in O(\log \frac{m}{n})$ times
<strong>ClassicallySparsify($G, \varepsilon&rsquo;$)</strong> with $\varepsilon&rsquo; \in
O(\frac{\varepsilon}{t})$ results in an $\varepsilon$-spectral sparsifier with
$\tilde{O}(\frac{n}{\varepsilon^2})$ edges.</p>
<p>Complexity-wise, the execution time of the provided algorithm is mostly
dominated by the construction of the
$\tilde{O}(\frac{1}{\varepsilon^2})$ spanners, each of which requires
time $\tilde{O}(m)$, giving a total time complexity of
$\tilde{O}(\frac{m}{\varepsilon^2})$.</p>
<h1 id="quantum-speed-up-for-graph-sparsification">Quantum speed-up for graph sparsification</h1>
<p>Apers and de Wolf propose a quantum analog to the sparsificationalgorithm described in . They build on results from classical and
quantum algorithms, in particular the classical algorithm for
sparsification by Koutis and Xu <span class="autoref">cs</span>, the
spanner algorithm by 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Mikkel"><span itemprop="familyName">Thorup</span></span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Uri"><span itemprop="familyName">Zwick</span></span>,&#32;<span itemprop="datePublished">2005</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Thorup</span>,&#32;
    <meta itemprop="givenName" content="Mikkel" />
    M.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Zwick</span>,&#32;
    <meta itemprop="givenName" content="Uri" />
    U.</span>
  &#32;
    (<span itemprop="datePublished">2005</span>).
  &#32;<span itemprop="name">Approximate distance oracles</span>.<i>
    <span itemprop="about">J. ACM</span>,&#32;52(1)</i>.&#32;<span itemprop="pagination">1–24</span>.
  <a href="https://doi.org/10.1145/1044731.1044732"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1145/1044731.1044732</a></span>




</span></span>)</span>
, the
quantum algorithm for single-source shortest-path trees by





<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Christoph"><span itemprop="familyName">Dürr</span></span>,&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Mark"><span itemprop="familyName">Heiligman</span></span>
                  <em>&amp; al.</em>,&#32;<span itemprop="datePublished">2006</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Dürr</span>,&#32;
    <meta itemprop="givenName" content="Christoph" />
    C.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Heiligman</span>,&#32;
    <meta itemprop="givenName" content="Mark" />
    M.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">HOyer</span>,&#32;
    <meta itemprop="givenName" content="Peter" />
    P.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Mhalla</span>,&#32;
    <meta itemprop="givenName" content="Mehdi" />
    M.</span>
  &#32;
    (<span itemprop="datePublished">2006</span>).
  &#32;<span itemprop="name">Quantum query complexity of some graph problems</span>.<i>
    <span itemprop="about">SIAM Journal on Computing</span>,&#32;35(6)</i>.&#32;<span itemprop="pagination">1310–1328</span>.
  <a href="https://doi.org/10.1137/050644719"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1137/050644719</a></span>




</span></span>)</span>
, and an efficient
$k$-independent hash function by





<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Tobias"><span itemprop="familyName">Christiani</span></span>,&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Rasmus"><span itemprop="familyName">Pagh</span></span>
                  <em>&amp; al.</em>,&#32;<span itemprop="datePublished">2015</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/CreativeWork"
      data-type="paper-conference"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Christiani</span>,&#32;
    <meta itemprop="givenName" content="Tobias" />
    T.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Pagh</span>,&#32;
    <meta itemprop="givenName" content="Rasmus" />
    R.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Thorup</span>,&#32;
    <meta itemprop="givenName" content="Mikkel" />
    M.</span>
  &#32;
    (<span itemprop="datePublished">2015</span>).
  &#32;<span itemprop="name">
    <i>From Independence to Expansion and Back Again</i></span>.
  <meta itemprop="contentLocation"
        content="Portland Oregon USA">&#32;
  <span itemprop="publisher" itemtype="http://schema.org/Organization" itemscope="">
    <span itemprop="name">ACM</span></span>.
  <a href="https://doi.org/10.1145/2746539.2746620"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1145/2746539.2746620</a></span>

</span></span>)</span>
.</p>
<h2 id="quantum-spanner-algorithm">Quantum spanner algorithm</h2>
<p>The quantum spanner algorithm proposed by 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Simon"><span itemprop="familyName">Apers</span></span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Ronald"><span itemprop="familyName">Wolf</span></span>,&#32;<span itemprop="datePublished">2019</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Apers</span>,&#32;
    <meta itemprop="givenName" content="Simon" />
    S.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Wolf</span>,&#32;
    <meta itemprop="givenName" content="Ronald" />
    R.</span>
  &#32;
    (<span itemprop="datePublished">2019</span>).
  &#32;<span itemprop="name">Quantum Speedup for Graph Sparsification, Cut Approximation and Laplacian Solving</span>.
  <a href="https://doi.org/10.48550/ARXIV.1911.07306"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.48550/ARXIV.1911.07306</a></span>




</span></span>)</span>
 is heavily
inspired by the best classical introduced by





<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Mikkel"><span itemprop="familyName">Thorup</span></span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Uri"><span itemprop="familyName">Zwick</span></span>,&#32;<span itemprop="datePublished">2005</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Thorup</span>,&#32;
    <meta itemprop="givenName" content="Mikkel" />
    M.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Zwick</span>,&#32;
    <meta itemprop="givenName" content="Uri" />
    U.</span>
  &#32;
    (<span itemprop="datePublished">2005</span>).
  &#32;<span itemprop="name">Approximate distance oracles</span>.<i>
    <span itemprop="about">J. ACM</span>,&#32;52(1)</i>.&#32;<span itemprop="pagination">1–24</span>.
  <a href="https://doi.org/10.1145/1044731.1044732"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1145/1044731.1044732</a></span>




</span></span>)</span>
: as such, the classical algorithm will be
introduced before the quantum one.</p>
<h3 id="classical-spanner-algorithm">Classical spanner algorithm</h3>
<p>In order to efficiently construct a graph spanner, 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Mikkel"><span itemprop="familyName">Thorup</span></span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Uri"><span itemprop="familyName">Zwick</span></span>,&#32;<span itemprop="datePublished">2005</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Thorup</span>,&#32;
    <meta itemprop="givenName" content="Mikkel" />
    M.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Zwick</span>,&#32;
    <meta itemprop="givenName" content="Uri" />
    U.</span>
  &#32;
    (<span itemprop="datePublished">2005</span>).
  &#32;<span itemprop="name">Approximate distance oracles</span>.<i>
    <span itemprop="about">J. ACM</span>,&#32;52(1)</i>.&#32;<span itemprop="pagination">1–24</span>.
  <a href="https://doi.org/10.1145/1044731.1044732"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1145/1044731.1044732</a></span>




</span></span>)</span>

designed a classical algorithm based on shortest-path trees.</p>
<h4 id="definition-2">Definition</h4>
<h5 id="shortest-path-tree">Shortest-path tree</h5>
<p>Inside a graph $G=(V,E)$, a shortest path tree $\mathcal T$, rooted at a node
$v_0$ and covering a subset $S\subseteq V$ of vertices, is a subgraph of $G$
such that for all nodes $v_S \in S$, the distance between $v_0$ and $v_S$ is the
same as in the original graph $G$, and is minimal in $G$.</p>
<p>Their algorithm constructs a $(2k-1)$-spanner $H$ of $G$ with
$O(k n^{1+1/k})$ edges, for some $k\in \mathbb{N}$. To do so, a family
${A_0,\dots, A_k}$ of node subsets is generated at random such that
$A_0=V$, $A_k = \emptyset$ and for all $i &lt; k$, $$\label{eq:ai-spanner}
A_i = {v \in A_{i-1}\ w.p.\ n^{-1/k}} \text{ ,}$$</p>
<p>i.e., $A_i$ contains each edge of the previous subset with probability
$n^{-1/k}$. At each iteration $i\leq k$, for all nodes
$v \notin A_i \cap A_{i-1}$, a shortest path tree $\mathcal T(v)$
spanning the ensemble of nodes $V&rsquo;$ is built from node $v$. $V&rsquo;$ is
defined such that for all $v&rsquo; \in V&rsquo;$, the distance between $v$ and $v&rsquo;$
is smaller than the distance between $v&rsquo;$ and all the nodes that belongs
to $A_i$. The resulting spanner is the union of all the shortest path
trees created thereby.</p>
<h3 id="quantum-spanner-algorithm-1">Quantum spanner algorithm</h3>
<p>The runtime of Thorup and Zwick&rsquo;s algorithm is dominated by the
construction of the shortest path trees. A quantum algorithm speeding up
this construction exists 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Christoph"><span itemprop="familyName">Dürr</span></span>,&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Mark"><span itemprop="familyName">Heiligman</span></span>
                  <em>&amp; al.</em>,&#32;<span itemprop="datePublished">2006</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Dürr</span>,&#32;
    <meta itemprop="givenName" content="Christoph" />
    C.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Heiligman</span>,&#32;
    <meta itemprop="givenName" content="Mark" />
    M.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">HOyer</span>,&#32;
    <meta itemprop="givenName" content="Peter" />
    P.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Mhalla</span>,&#32;
    <meta itemprop="givenName" content="Mehdi" />
    M.</span>
  &#32;
    (<span itemprop="datePublished">2006</span>).
  &#32;<span itemprop="name">Quantum query complexity of some graph problems</span>.<i>
    <span itemprop="about">SIAM Journal on Computing</span>,&#32;35(6)</i>.&#32;<span itemprop="pagination">1310–1328</span>.
  <a href="https://doi.org/10.1137/050644719"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1137/050644719</a></span>




</span></span>)</span>
, and is strongly
inspired by Dijkstra&rsquo;s algorithm. In the latter, a tree $\mathcal{T}$
rooted at a node $v_0$ is recursively grown by adding the cheapest
border<sup id="fnref:1"><a href="https://thmhugo.github.io" class="footnote-ref" role="doc-noteref">1</a></sup> edge, i.e the edge $(i,j)$ such that
$$cost(i,j)= \min{ cost(u,v) | u\in\mathcal{T},v\notin \mathcal{T}} \ ,$$
where $cost(i,j) = \delta(v_0,i) + \frac{1}{w(i,j)}$. The quantum time
improvement arises from a speedup for the selection of the cheapest
border edge. The quantum routine called in the quantum shortest path
tree algorithm is the <em>minimum finding</em> quantum algorithm
$\text{MINFIND}(d,f,g)$, which takes as inputs</p>
<ul>
<li>
<p>a <em>value</em> function $f : [N] \rightarrow \mathbb{R} \cup {\infty}$</p>
</li>
<li>
<p>a <em>type</em> function $g : [N] \rightarrow \mathbb{N}$</p>
</li>
<li>
<p>an integer $d \leq \dfrac N2$</p>
</li>
</ul>
<p>and outputs a subset $I \subseteq [N]$ of size $|I| = \min{d,M}$,
where $M = |Im(g)|$, such that every distinct elements of $I$ have a
different type, i.e. for all $i,j \in I$ $$g(i) \neq g(j)\ ,$$ and for
$j\notin I$ and $i \in I$, having $f(j) &lt; f(i)$ implies that there exists
an $i&rsquo; \in I$ so that $$f(i&rsquo;)\leq f(i) \text{ and } g(i&rsquo;)= g(j)\ ,$$
i.e., $j$ and $i&rsquo;$ have the same type.</p>
<p>Let $P_L$ be a subset of nodes and $E(P_L)$ the set of edges such that
$\forall (u,v) \in E(P_L)$, $u \in P_L \text{ or } v \in P_L$. In
<span class="autoref">qspt</span>, the functions $f$ and
$g$ are both defined on $E(P_L)$, in such a way that $g((u,v)) = v$ and
$$f((u,v)) = \begin{cases}
cost(u,v)=dist(u) + \frac{1}{w(u,v)} &amp; \text{if } u\in P_L,, v\notin T \\\
\infty &amp; \text{otherwise.}
\end{cases}$$</p>
<p>In other words, we are looking for a subset of the border edges of the
set of nodes $P_L$ that contains at most one edge for each node in
$P_L$, and if several edges are possible, the least costly is kept. A
brief explanation follows.</p>
<pre class="algorithm" id = 'qspt'>
\begin{algorithm}
\caption{\textbf{QuantumSPT}($G=(V,E),v_0$)}
\begin{algorithmic}
\REQUIRE $T =( V_T=\{v_0\}, E_T =\emptyset) $
\REQUIRE $P_1 = \{v_0\}$ and $L=1$

\STATE  set $\text{dist}(v_0) = 0$ and $\forall u\in V, u \neq v_0$, $\text{dist}(u) = \infty$

\WHILE{$|V_T| < n$}
    \STATE $B_L = \text{MINFIND}(|P_L|,f,g)$
    \STATE \textit{Let $(u,v) \in B_1 \cup \dots \cup B_L$ have minimal $\text{cost}(u,v)$
        with $v\notin P_1 \cup \dots \cup P_L$}
    \IF{$w(u,v)=0$}
        \RETURN $\mathcal{T}$
    \ELSE
        \STATE $V_T \leftarrow V_T \cup \{v\}$ , $E_T \leftarrow E_T \cup \{(u,v)\}$
        \STATE $\text{dist}(v) = \text{dist}(u) + 1/w(u,v)$
        \STATE $P_{L+1} \leftarrow \{v\}$ , $L \leftarrow L+1$
    \ENDIF

    \WHILE{ $L \geq 2$ and $|P_L| = |P_{L-1}|$}
        \STATE \textit{merge $P_L$ into $P_{L-1}$}
        \STATE $L \leftarrow L-1$
    \ENDWHILE
\ENDWHILE
\end{algorithmic}
\end{algorithm}
</pre>
<p>In <span class="autoref">qspt</span>, a set of $L$ partitions
${P_l}_{l=1}^L$ of the vertices covered by the shortest path tree
$\mathcal T$ is generated, and the algorithm stops only when
$\mathcal T$ covers the connected component of $v_0$.</p>
<p>Step 1 initializes the distances, as does Dijkstra&rsquo;s algorithm. In Step
4, a set $B_L$ containing the $|P_L|$ cheapest border edges with
disjoint target vertices is generated by the quantum routine
$\text{MINFIND}(|P_L|,f,g)$. Step 10 updates the distance of the
selected vertex, in a same manner as in Dijkstra&rsquo;s. After all the merges
of Step 13, the $P_k$ are sets of vertices of the growing tree, so that
$|P_k| = 2^{L-k}$. This ensures that since $B_k$ contains $|P_k|$ edges,
then at least one of these edges has its target outside of $\cup_{j=1}^L
P_k$ , implying in Step 5 at least one border edge exists, and is
effectively selected, thus the correctness of the algorithm (see





<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Simon"><span itemprop="familyName">Apers</span></span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Ronald"><span itemprop="familyName">Wolf</span></span>,&#32;<span itemprop="datePublished">2019</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Apers</span>,&#32;
    <meta itemprop="givenName" content="Simon" />
    S.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Wolf</span>,&#32;
    <meta itemprop="givenName" content="Ronald" />
    R.</span>
  &#32;
    (<span itemprop="datePublished">2019</span>).
  &#32;<span itemprop="name">Quantum Speedup for Graph Sparsification, Cut Approximation and Laplacian Solving</span>.
  <a href="https://doi.org/10.48550/ARXIV.1911.07306"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.48550/ARXIV.1911.07306</a></span>




</span></span>)</span>
 Appendix A, Proposition 5}). As a side note, at
each step $V_{\mathcal{T}}$ contains the growing tree.</p>
<pre class="algorithm" id="quantum-spanner">
\begin{algorithm}
\caption{\textbf{QuantumSpanner$(G=(V,E), k)$}}
\begin{algorithmic}
\REQUIRE $A_0 = V$ ans $A_k = \emptyset$
\ENSURE \textit{$H$ is initially an empty graph}
\FOR {$i=1, \cdots, k$}
    \IF{$i < k$}
        \STATE \textit{set $A_i$ such as defined in $\cdots$}
    \ENDIF
    \FORALL{$v \in A_{i-1} - A_i$}
        \STATE $\mathcal T \leftarrow \mathbf{QuantumSPT}(G, v)$
        \STATE $H \leftarrow H \cup \mathcal T$
    \ENDFOR
\ENDFOR
\RETURN H
\end{algorithmic}
\end{algorithm}
</pre>
<h4 id="thm:comp-spt">Theorem</h4>
<p>In the worst case, <span class="autoref">qspt</span> returns a shortest path tree
covering the graph $G=(V,E)$ in time $\tilde{O}(\sqrt{mn})$.*</p>
<p>More precisely, the running time depends on the size of the connected
component in which the starting node $v_0$ is. Taking into account , one
can conclude on the overall time complexity of <span class="autoref">quantum-spanner</span>.</p>
<h4 id="thmqSpanner">Theorem</h4>
<p>There exists a quantum algorithm that outputs in time $\tilde{O}(k n^{1/k}
\sqrt{mn})$ with high probability a $(2k-1)$-spanner of $G$ with an expected
number of edges $O(k n^{1+1/k})$.</p>
<p>To conclude, setting $k= \log n + 1/2$, one can construct
$(2 \log n)$-spanners of an input graph with $n$ nodes and $m$ edges in
time $\tilde{O}(\sqrt{mn})$.</p>
<h2 id="implicit-construction-of-the-graph-though-a-string">Implicit construction of the graph though a <em>string</em></h2>
<p>In order to stay within a sublinear runtime, one cannot use an explicit
representation as used by Koutis and Xu in the algorithm of
<a href="https://thmhugo.github.io">classical spartification</a>: indeed,
after a single iteration, the outputted graph could have up to
$\frac m2\in O(n^2)$ edges (see e.g., ).</p>
<p>Apers and de Wolf address this issue by constructing a random string
$r \in {0,1}^{m}$ encoding the discarded edges at some iteration with
0-valued bits, and later implicitly setting the corresponding weights in
the graph to 0, as shown in <span class="autoref">quantum-sparsify</span>. This enables
the construction of a spanner in the remaining graph. One can then use a
Grover search to the undiscarded $\tilde{O}(n/\varepsilon^{2})$ edges,
whose union forms the spectral sparsifier. In addition, it is possible
to further improve the classical complexity, since a $k$-query quantum
algorithm cannot distinguish a $2k$-wise independent strings from a
uniformly random one 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Mark"><span itemprop="familyName">Zhandry</span></span>,&#32;<span itemprop="datePublished">2015</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Zhandry</span>,&#32;
    <meta itemprop="givenName" content="Mark" />
    M.</span>
  &#32;
    (<span itemprop="datePublished">2015</span>).
  &#32;<span itemprop="name">Secure identity-based encryption in the quantum random oracle model</span>.<i>
    <span itemprop="about">International Journal of Quantum Information</span>,&#32;13(04)</i>.&#32;<span itemprop="pagination">1550014</span>.
  <a href="https://doi.org/10.1142/S0219749915500148"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1142/S0219749915500148</a></span>




</span></span>)</span>
.</p>
<p>At first, a family of independent random bit-strings
$$r_i \in {0,1}^{m} \text{, } ; i \in \big[\log \frac mn\big] \text{ ,}$$
is considered, such that all bits are <em>independent</em> and <em>equal to 1 with
probability 1/4</em>.</p>
<p>Thus the graph is represented throughout the execution with a bit-string
$r$, where each bit $b_e$ is sampled only when edge $e$ is queried.</p>
<p>However, thanks to the result of 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Mark"><span itemprop="familyName">Zhandry</span></span>,&#32;<span itemprop="datePublished">2015</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Zhandry</span>,&#32;
    <meta itemprop="givenName" content="Mark" />
    M.</span>
  &#32;
    (<span itemprop="datePublished">2015</span>).
  &#32;<span itemprop="name">Secure identity-based encryption in the quantum random oracle model</span>.<i>
    <span itemprop="about">International Journal of Quantum Information</span>,&#32;13(04)</i>.&#32;<span itemprop="pagination">1550014</span>.
  <a href="https://doi.org/10.1142/S0219749915500148"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1142/S0219749915500148</a></span>




</span></span>)</span>
, it is possible to discard
the random strings by considering $k$-independent hash functions, whose
<a href="https://thmhugo.github.io">definition</a> is recalled below. Hence,
such a structure allows to query for a bit-string element in time $\tilde{O}(1)$
without even having to store the bit-string, but still being able to retrieve
it. It is important to stress that it is a purely classical result.</p>
<h4 id="defkIndependentHashing">Definition</h4>
<h5 id="k-independent-hashing-functions">$k$-independent hashing functions</h5>
<p>Let $\mathcal U$ be the set of keys. A family $\mathcal{H} = { h : \mathcal
U \rightarrow [m]}$ is said to be $k$-independent if for all keys $x_1,
\cdots, x_k$ in $\mathcal U$ pairwise distinct and for all values $v_1, \cdots,
v_k$ in $[m]$,
$$\big| { h \in \mathcal H ; \quad  h(x_1)=v_1, \cdots, h(x_k)=v_k } \big| =
\frac{|\mathcal H |}{m^k} \ ,$$
in other words, by providing $\mathcal H$ with the uniform probability, for any
$h\in \mathcal H$,
$$\mathbb{P}\big(h(x_1)=v_1, \cdots,  h(x_k)=v_k \big) = \frac{1}{m^k} \text{
.}$$</p>
<p>A quantum oracle that keeps track of the weight updates is easily
constructed. Considering the $i^{th}$ iteration; given an edge $e$, let
$k$ denote the number of spanners in which $e$ appears before this
iteration.</p>
<p>If $k=0$, the weight of the edge $e$ is re-weighted as follows:
$$\omega_e&rsquo; =
\begin{cases}
4^i\omega_e &amp; \text{ if } \bigvee\limits_{l=1}^i r_l(e) = 1 \\\
0 &amp; \text{ otherwise.}
\end{cases}$$ Otherwise, in the case where $k&gt;0$, the weight of the
edge $e$ is re-weighted in a different manner, so that $$\omega_e&rsquo; =
\begin{cases}
4^{i-k}\omega_e &amp; \text{if } \bigvee\limits_{l=1}^{j+1} r_l(e) = 1 \\\
0 &amp; \text{otherwise,}
\end{cases}$$ where $\vee$ is the logical disjunction.</p>
<pre class="algorithm" id="quantum-sparsify">
\begin{algorithm}
\caption{\textbf{QuantumSparsify}($G,\epsilon$)}
\begin{algorithmic}
\REQUIRE $\forall e, \; w_e' = w_e$ and $l=\lceil \log\frac mn \rceil$
\REQUIRE $\forall i\in[\log(m/n)], \; r_i \in \{0,1\}^m$, \Comment{A family of
random strings such that all bits are independent and equal to 1 w.p. $\frac {1}{4}$.}
% \ENSURE $\tilde{G}$ is an $\epsilon$-spectral sparsifier  of $G$ with $\tilde{O}(n/\epsilon^2)$ edges.
\For{$i = 1,2,...,l$}
\STATE \textit{create $H_i$, union of an $O(\frac{\log^2 n}{\epsilon ^2})$-packing of
        spanners of $G' = (V,E,w')$}
\ForAll{$e \notin H_i$}
\If{$r_i(e) = 1$}
\STATE $w_e' \leftarrow 4\,w_e'$
\Else
\STATE $w_e' \leftarrow 0$
\EndIf
\EndFor
\EndFor
\STATE \textit{use repeated Grover search to find $\tilde{E} = \{ e \in E | w_e^{'} > 0\}$ the edges of $\tilde{G}$ }
\STATE \RETURN $\tilde{G}$
\end{algorithmic}
\end{algorithm}
</pre>
<p>Intuitively, the unions of the
$O(\frac{\log^2 n}{\varepsilon^2})$-packing of spanners select the
<em>most</em> important edges of the graph, and the conditional reweighting
(Steps 4,5) is a way of keeping a fraction of the remaining edges in
order to <em>spectrally</em> preserve the graph (i.e., asserts that in the end
it effectively $(1+\varepsilon)$-approximates the input graph). In each
iteration, the remaining graph is classically sparsified using
<span class="autoref">cs</span>. The
sparsified graph is the one induced by the vertices of the initial graph
and the edges whose weight $w_e^{&rsquo;}$ is greater than $0$.</p>
<h4 id="proposition">Proposition</h4>
<p>The probability that all $\log \frac mn$ iterations succeed
is $1 - O(\frac{\log n}{n^2})$.</p>
<p><em>Proof</em> : Let $p_s$ be the probability of success and $p_f$ be the probability of
failure. If $p_s = 1-\frac{1}{n^2}$ then $p_e = \frac{1}{n^2}$, since
$\log \frac{m}{n}$ are done, the global probability of failure $P_f$ is
the sum of each $p_f$, such that
$$P_f = \frac{1}{n^2} \times \log \frac{m}{n}.$$ Since $m$ is the number
of edges of the input graph, $$m \leq \binom{n}{2}\in O(n^2),$$ thus
$$\log \frac mn \in O\big(\log \frac{n^2}{n}\big) = O(\log n)\text{ ,}$$
hence $$p_e = O\big(\frac{\log n}{n^2}\big)\text{ ,}$$ the result
follows.
:::</p>
<p>The overall time complexity of the algorithm depends on whether the
$(r_i)_i$ are represented with a random string. By
<a href="https://thmhugo.github.io">definition</a>, the set of
spanners is assumed ordered, allowing to binary search through the set
in time $\tilde{O}(1)$, and there is $O(i)$ calls to the aforementioned
oracle. The algorithm requires $O(\log n)$ qubits, which is the number
of qubits needed for the quantum spanner algorithm and the repeated
Grover search. In addition a QRAM <sup id="fnref:2"><a href="https://thmhugo.github.io" class="footnote-ref" role="doc-noteref">2</a></sup> of $\tilde{O}(n/\varepsilon^2)$
bits is required since the classical space complexity is dominated by
the output size, i.e. the size of the graph.</p>
<p>It is possible to simulate the random strings in <span class="autoref">quantum-sparsify</span> with
$k$-independent hash functions, and hence improve the classical space
complexity from $\tilde{O}(n/\varepsilon^2)$ to
$\tilde{O}(\sqrt{mn}/\varepsilon^2)$.</p>
<p>Considering the efficiently computable search function
$f : E \rightarrow {0,1}$ such that $$f(e) = \begin{cases}
1  &amp; \text{if } w&rsquo;_e &gt;0 \\\
0 &amp; \text{otherwise}
\end{cases}
\text{,}$$ Grover&rsquo;s algorithm finds a single edge in time
$\tilde{O}(\sqrt{\frac{m}{n/\varepsilon^2}})$. Therefore, retrieving
$\tilde{O}(n/\varepsilon^2)$ edges belonging to $\tilde{G}$ takes time
$\tilde{O}(\frac{\sqrt{m,n}}{\varepsilon})$.<br>
As stated in , one can construct a $(\log^2 n / \varepsilon^2)$-spanner
in time $\tilde{O}(\sqrt{mn}/\varepsilon^2)$.</p>
<p>The overall time complexity is the sum of the runtimes needed to
simulate the random string, to construct a spanner and for the repeated
Grover search. Therefore, the total runtime is
$$2 \tilde{O}(\sqrt{mn}/\varepsilon^2) + \tilde{O}(\sqrt{mn}/\varepsilon) = \tilde{O}(\sqrt{mn}/\varepsilon^2) \ .$$</p>
<h4 id="th:qu-spectral-sparsification" class="theorem">Theorem</h4>
<h5 id="quantum-spectral-sparsification">Quantum Spectral Sparsification</h5>
<p>The algorithm <strong>QuantumSparsify</strong>$(G,\varepsilon)$ returns with probability
$1-O(\log n/n^2)$ an $\varepsilon$-spectral sparsifier of $G$ with
$\tilde{O}(n/\varepsilon^2)$ edges, in time
$\tilde{O}(\sqrt{m,n}/\varepsilon^2)$ and using a QRAM of
$\tilde{O}(\sqrt{m,n}/\varepsilon^2)$ bits.</p>
<h2 id="time-improvement-of-quantum-sparsification">Time improvement of quantum sparsification</h2>
<h3 id="approximate-resistance-oracle-and-spectral-sparsification">Approximate resistance oracle and spectral sparsification</h3>
<p>From the result of Spielman and Srivastava 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Daniel A."><span itemprop="familyName">Spielman</span></span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Nikhil"><span itemprop="familyName">Srivastava</span></span>,&#32;<span itemprop="datePublished">2011</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Spielman</span>,&#32;
    <meta itemprop="givenName" content="Daniel A." />
    D.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Srivastava</span>,&#32;
    <meta itemprop="givenName" content="Nikhil" />
    N.</span>
  &#32;
    (<span itemprop="datePublished">2011</span>).
  &#32;<span itemprop="name">Graph Sparsification by Effective Resistances</span>.<i>
    <span itemprop="about">SIAM Journal on Computing</span>,&#32;40(6)</i>.&#32;<span itemprop="pagination">1913–1926</span>.
  <a href="https://doi.org/10.1137/080734029"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1137/080734029</a></span>




</span></span>)</span>
, one can
compute a matrix $Z$ such that for all pairs $(s,t)$ of edges in $G$,
$$\label{eq:matrix-z} (1-\varepsilon) R_{s,t} \leq || Z\cdot(\chi_s-\chi_t)^2 ||
\leq (1+\varepsilon) R_{s,t}$$
in time $\tilde{O}(m/\varepsilon^2)$. $Z$ is defined as $Z =
QW^{\frac{1}{2}}BL^+$, where $L=B^TWB$ with $B$ the incidence matrix and $W$ a
diagonal matrix such that $(W)_{ii} = \omega_{e_i}$, and $Q$ a random $\pm
1/\sqrt k$ matrix (i.e., independent Bernoulli entries).  Consequently, thanks
to , the matrix $Z$ helps $\varepsilon$-approximate the effective resistance
between any edge $e = (s,t)$ of the initial graph.</p>
<p>The proof of the existence of such a $Z$ matrix allows one to
efficiently create an oracle for the quantum algorithm.</p>
<h4 id="th:app-resistance-oracle" class="theorem">Theorem</h4>
<h5 id="sparsification-with-approximate-resistances-hahahugoshortcode-s22-hbhb">Sparsification with approximate resistances 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Daniel A."><span itemprop="familyName">Spielman</span></span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Nikhil"><span itemprop="familyName">Srivastava</span></span>,&#32;<span itemprop="datePublished">2011</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Spielman</span>,&#32;
    <meta itemprop="givenName" content="Daniel A." />
    D.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Srivastava</span>,&#32;
    <meta itemprop="givenName" content="Nikhil" />
    N.</span>
  &#32;
    (<span itemprop="datePublished">2011</span>).
  &#32;<span itemprop="name">Graph Sparsification by Effective Resistances</span>.<i>
    <span itemprop="about">SIAM Journal on Computing</span>,&#32;40(6)</i>.&#32;<span itemprop="pagination">1913–1926</span>.
  <a href="https://doi.org/10.1137/080734029"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1137/080734029</a></span>




</span></span>)</span>
</h5>
<p>Let $R_e/2 \leq \tilde{R_e} \leq 2R_e$ be a rough approximation of $R_e$, for
each $e\in E$ and $p_e = min(1,Cw_e\tilde{R_e}\log(n)/\varepsilon^2)$. Then,
with probability $1-1/n$, an $\varepsilon$-spectral sparsifier $H$ with
$O(n\log(n)/\varepsilon^2)$ edges can be obtained by keeping every edge $e$
independently with probability $p_e$ and rescaling its weight with $1/p_e$.</p>
<p>allows one to efficiently define the ${p_e}$ according the effective
resistance approximations ${\tilde {R_e}}$.</p>
<p>Since $H$ is an $\varepsilon$-spectral sparsifier of $G$, we have that
for all edge $e$ of $H$,
$$(1-1/\varepsilon) R^G_e \leq R^H_e \leq (1+1/\varepsilon) R^G_e \ ,$$
where $R^G_e$ and $R^H_e$ are effective resistances in $G$ and $H$,
respectively. From , the effective resistances $R_e$ can be approximated
with the matrix $Z$ in such a way that for an edge $e = (s,t)$, the
approximated resistance is
$$\tilde{R_e} = || Z \cdot (\chi_s-\chi_t)^2 || \text{ .}$$ The
probability $p_e$ of keeping an edge $e$ is taken to be proportional to
$\tilde{R_e}$, since an edge will be more important if it belongs to a
weak component, i.e. if it has a high effective resistance. Thanks to
the result of 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Béla"><span itemprop="familyName">Bollobás</span></span>,&#32;<span itemprop="datePublished">1998</span></a><span class="hugo-cite-citation"> 










<span itemscope 
      itemtype="https://schema.org/Book"
      data-type="book"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Bollobás</span>,&#32;
    <meta itemprop="givenName" content="Béla" />
    B.</span>&#32;
    (<span itemprop="datePublished">1998</span>).
  &#32;<span itemprop="name">
    <i>Modern Graph Theory</i></span>.
  <meta itemprop="contentLocation"
        value="New York, NY">&#32;
  <span itemprop="publisher"
             itemtype="http://schema.org/Organization"
             itemscope="">
    <span itemprop="name">Springer New York</span></span>.
  <a href="https://doi.org/10.1007/978-1-4612-0619-4"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1007/978-1-4612-0619-4</a></span>




</span></span>)</span>
 Theorem 25,
$$\sum_e w_e R_e = n-1$$ for connected graphs of order $n$ <sup id="fnref:3"><a href="https://thmhugo.github.io" class="footnote-ref" role="doc-noteref">3</a></sup>, and
thus, one has that $\sum_e w_e \tilde{R_e} = O(n)$. Since $\sum_e p_e$
represents the number of edges in the sparsifier, if one wants to end up
with $O(n \log n /\varepsilon^2)$ edges in the resulting graph, $p_e$
should be taken proportional to
$w_e \tilde{R_e} \log (n) / \varepsilon^2$.</p>
<p>In order to keep a satisfying approximation of the weights ${w_e}$ in
the sparsifier, we want to keep unchanged the expectation value of the
weight of each edge. Hence<sup id="fnref:4"><a href="https://thmhugo.github.io" class="footnote-ref" role="doc-noteref">4</a></sup>, every weight $w_e$ is re-scaled by
$1/p_e$ i.e., $\tilde{w_e} = \frac{w_e}{p_e}$.</p>
<h3 id="edge-sampling">Edge sampling</h3>
<p>Classically, <span class="autoref">edge-sampling</span>
shows how one can sample a subset of edges that contains every edge $e$
independently with probability $p_e$, in time
$\tilde{O}(m + \sum_e p_e)$.</p>
<pre class="algorithm" id="edge-sampling">
\begin{algorithm}
\caption{\textbf{ClassicalEdgeSampling}($G,\epsilon$)}
\begin{algorithmic}
    \REQUIRE $S = \emptyset$
    \STATE \textit{approximate $\{p_e\}_{e\in E}$ using $\cdots$}
    \ForAll{$e \in E$}
        \STATE \textit{add edge $e$ to $S$ with probability $p_e$ }
    \EndFor
    \RETURN S
\end{algorithmic}
\end{algorithm}
</pre>
<p>A quantum algorithm could sample a subset of edges more efficiently. We
assume we have access to a random string $r \in {0,1}^{\tilde{O}(m)}$
through the hash function $h_r: E\times [0,1] \rightarrow {0,1}$, such
that for all $e\in E$, $h_r(e,p_e) = 1$ with probability $p_e$ and
$h_r(e,p_e)=0$ otherwise. From this, it is possible to construct the
following oracle
$$O_s : \ket{e} \ket{v} \ket{w} \longmapsto \ket{e} \ket{v \oplus p_e} \ket{w \oplus h_r(e,p_e)} \ .$$</p>
<p>Due to the fact that the expected number of edges $e$ for which
$h_r(e,p_e)=1$ is $\sum_e p_e$, a repeated Grover search finds the
desired edges in time $\tilde{O}(\sqrt{m \sum_e p_e})$.</p>
<h3 id="refined-quantum-sparsification-algorithm">Refined quantum sparsification algorithm</h3>
<p>The runtime of <span class="autoref">quantum-sparsify</span> can be
improved to $\tilde{O}(\sqrt{mn}/\varepsilon)$ by creating a first
&quot;rough&quot; $\varepsilon$-sparsifier $H$, estimating the effective
resistances of $G$ from $H$ using Laplacian solving, and then using
quantum sampling in order to sample a subset containing
$\tilde{O}(n/\varepsilon^2)$ edges.</p>
<pre class="algorithm" id="refined-quantum-sparsify">
\begin{algorithm}
\caption{\textbf{RefinedQuantumSparsify}($G,\epsilon$)}
\begin{algorithmic}
    \STATE \textit{use $\cdots$ to construct a $(1/100)$-spectral sparsifier $H$ of $G$}
    \STATE \textit{create a $(1/100)$-approximate resistance oracle of
        $H$ using $\cdots$, yielding estimations
            $\tilde{R_e}$}
    \STATE \textit{use quantum sampling to sample a subset of the
        edges, keeping every edge with probability $\, p_e =
        min(1,Cw_e\tilde{R_e}\log(n)/\epsilon^2)$}
\end{algorithmic}
\end{algorithm}
</pre>
<p>The Step 1 of <span class="autoref">refined-quantum-sparsify</span> requires for
$\tilde{O}(\sqrt{mn})$ to construct the $1/100$-spectral sparsifier $H$,
in which each edge $e$ is such that its effective resistance $R_e^H$
satisfies $$(1-1/100) R^G_e \leq R^H_e \leq (1+1/100) R^G_e\ .$$
According to , there exists an oracle to derive approximated resistances
${\tilde{R_e}}$ in Step 2 such that, for all edges $e=(s,t)$,
$$(1-1/100) R^H_e \leq \tilde{R^H_e} \leq (1+1/100) R^H_e \ ,$$ where
$\tilde{R^H_e} = || Z\cdot(\chi_s-\chi_t)^2 ||$. One can then deduce
that $$(1-1/100)^2 R^G_e \leq \tilde{R^H_e} \leq (1+1/100)^2 R^G_e \ .$$</p>
<p>Supposing that each edge $e$ is kept with probability
$$p_e = \min(1,C w_e \tilde{R^H_e} \log(n)/\varepsilon^2) \ ,$$ an
$\varepsilon$-spectral sparsifier can be constructed with
$O(n \log(n)/\varepsilon^2)$ edges according to . The approximate oracle
needed for this step requires time $\tilde{O}(n)$ to be constructed.</p>
<p>The quantum routine of Step 3 takes time
$\tilde{O}(\sqrt{m \sum_e p_e})$ where $$\begin{aligned}
\sum_e p_e
&amp; \leq \frac{C \log(n)}{\varepsilon^2} \sum_e w_e \tilde{R^H_e} \\\
&amp; \leq \dfrac{(1+1/100)^2 C \log(n)}{\varepsilon^2} \sum_e w_e R^G_e \ .
\end{aligned}$$ As stated in 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Béla"><span itemprop="familyName">Bollobás</span></span>,&#32;<span itemprop="datePublished">1998</span></a><span class="hugo-cite-citation"> 










<span itemscope 
      itemtype="https://schema.org/Book"
      data-type="book"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Bollobás</span>,&#32;
    <meta itemprop="givenName" content="Béla" />
    B.</span>&#32;
    (<span itemprop="datePublished">1998</span>).
  &#32;<span itemprop="name">
    <i>Modern Graph Theory</i></span>.
  <meta itemprop="contentLocation"
        value="New York, NY">&#32;
  <span itemprop="publisher"
             itemtype="http://schema.org/Organization"
             itemscope="">
    <span itemprop="name">Springer New York</span></span>.
  <a href="https://doi.org/10.1007/978-1-4612-0619-4"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1007/978-1-4612-0619-4</a></span>




</span></span>)</span>
, one always has
that for a connected graph of order $n$, $\sum_e w_e R^G_e = n-1$.
Therefore, we can conclude that
$\sum_e p_e \in \tilde{O}(n/\varepsilon^2)$ which implies that the total
runtime of the quantum sampling routine is
$\tilde{O}(\sqrt{mn}/\varepsilon)$.</p>
<p>One can notice that Step 2 only succeeds with probability $1-\frac 1n$
as claimed by . According to that, one can abort the algorithm as soon
as the runtime exceeds $\tilde{O}(\sqrt{mn}/\varepsilon)$ and start
again, yielding a runtime of
$\tilde{O}(2 \sqrt{mn}/\varepsilon) = \tilde{O}(\sqrt{mn}/\varepsilon)$
in the worst case.<br>
The total runtime of <span class="autoref">refined-quantum-sparsify</span> is the sum
of the runtimes of the three steps and it is therefore
$\tilde{O}(\sqrt{mn})$.</p>
<h4 id="theorem-1">Theorem</h4>
<h5 id="quantum-spectral-sparsification-1">Quantum Spectral Sparsification</h5>
<p><strong>RefinedQuantumSparsify</strong>($G$,$\varepsilon)$ returns with high
probability an $\varepsilon$-spectral sparsifier $H$ with
$\tilde{O}(n/\varepsilon^2)$ edges, and has runtime
$\tilde{O}(\sqrt{mn}/\varepsilon)$. The algorithm uses $O(\log, n)$
qubits and a QRAM of $\tilde{O}(\sqrt{mn}/\varepsilon)$.</p>
<p>Having arrived to , the main result of the paper was made explicit.





<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Simon"><span itemprop="familyName">Apers</span></span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Ronald"><span itemprop="familyName">Wolf</span></span>,&#32;<span itemprop="datePublished">2019</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Apers</span>,&#32;
    <meta itemprop="givenName" content="Simon" />
    S.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Wolf</span>,&#32;
    <meta itemprop="givenName" content="Ronald" />
    R.</span>
  &#32;
    (<span itemprop="datePublished">2019</span>).
  &#32;<span itemprop="name">Quantum Speedup for Graph Sparsification, Cut Approximation and Laplacian Solving</span>.
  <a href="https://doi.org/10.48550/ARXIV.1911.07306"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.48550/ARXIV.1911.07306</a></span>




</span></span>)</span>
&rsquo;s algorithm thus implies a quantum speedup for
solving Laplacian systems and for approximating a range of cut problems
such as min cut and sparsest cut.</p>
<p>This result can probably be combined with recent classical results such
as 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Li"><span itemprop="familyName">Chen</span></span>,&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Rasmus"><span itemprop="familyName">Kyng</span></span>
                  <em>&amp; al.</em>,&#32;<span itemprop="datePublished">2022</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Chen</span>,&#32;
    <meta itemprop="givenName" content="Li" />
    L.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Kyng</span>,&#32;
    <meta itemprop="givenName" content="Rasmus" />
    R.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Liu</span>,&#32;
    <meta itemprop="givenName" content="Yang P." />
    Y.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Peng</span>,&#32;
    <meta itemprop="givenName" content="Richard" />
    R.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Gutenberg</span>,&#32;
    <meta itemprop="givenName" content="Maximilian Probst" />
    M.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Sachdeva</span>,&#32;
    <meta itemprop="givenName" content="Sushant" />
    S.</span>
  &#32;
    (<span itemprop="datePublished">2022</span>).
  &#32;<span itemprop="name">Maximum Flow and Minimum-Cost Flow in Almost-Linear Time</span>.
  <a href="https://doi.org/10.48550/ARXIV.2203.00671"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.48550/ARXIV.2203.00671</a></span>




</span></span>)</span>
 to yield even faster algorithms. Stay tuned...</p>
<h1 id="ap:qram">QRAM Model</h1>
<p>To achieve the speed-up promised by the quantum algorithms presented
hereby, we assume the existence of a quantum device able to run quantum
subroutines on at most $O(\log N)$ qubits, where $N$ is the size of the
problem or the input.<br>
Besides, we assume an access to a Quantum Random Access Memory (QRAM)
which is, as its classical analog, composed of an <em>input</em> register, a
<em>memory</em> array and an <em>output</em> register. The main variations are that
the input and output registers are composed of qubits rather than bits.
Thus, the quantum computer can address memory in superposition meaning
that a superposition of inputs returns a superposition of outputs, so
that one can design the following quantum unitary
$$\sum_j \lambda_j |j\rangle_{in} |0\rangle_{out}  \xrightarrow{QRAM \ access}\  \ \sum_j \lambda_j  |j\rangle_{in} |v_j\rangle_{out}$$
where $in$, $out$ represent respectively the <em>input</em> and the <em>output</em>
registers and $v_j$ the value contained in the $j^{th}$ register. Hence, a
reading operation corresponds to a quantum query to the classical bits
stored in the memory array, whereas the operation of writing a bit in
the QRAM stays classical.<br>
Within this computational model, the complexity of an algorithm can have
several definitions. One can consider either the <em>time complexity</em>,
which counts the number of elementary gates (classical and quantum), of
quantum queries to the input and of QRAM operations, or the <em>query
complexity</em> which only counts the number of quantum queries to the
input. As an example of actual QRAM, a quantum optical implementation is
presented in 




<span class="hugo-cite-intext"
        itemprop="citation">(<span class="hugo-cite-group">

          <a href="https://thmhugo.github.io"><span class="visually-hidden">Citation: </span><span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Vittorio"><span itemprop="familyName">Giovannetti</span></span>,&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="givenName" content="Seth"><span itemprop="familyName">Lloyd</span></span>
                  <em>&amp; al.</em>,&#32;<span itemprop="datePublished">2008</span></a><span class="hugo-cite-citation"> 










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Giovannetti</span>,&#32;
    <meta itemprop="givenName" content="Vittorio" />
    V.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Lloyd</span>,&#32;
    <meta itemprop="givenName" content="Seth" />
    S.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Maccone</span>,&#32;
    <meta itemprop="givenName" content="Lorenzo" />
    L.</span>
  &#32;
    (<span itemprop="datePublished">2008</span>).
  &#32;<span itemprop="name">Quantum random access memory</span>.<i>
    <span itemprop="about">Phys. Rev. Lett.</span>,&#32;100</i>.&#32;<span itemprop="pagination">160501</span>.
  <a href="https://doi.org/10.1103/PhysRevLett.100.160501"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1103/PhysRevLett.100.160501</a></span>




</span></span>)</span>
.</p>
<h1 id="bibliography">Bibliography</h1>

  

  










<section class="hugo-cite-bibliography">
  <dl>
    

      <div id="durr_heiligman_2006">
        <dt>
          Dürr,&#32;
          Heiligman,&#32;
          HOyer&#32;&amp;&#32;Mhalla

          
          (2006)</dt>

        <dd>
          










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Dürr</span>,&#32;
    <meta itemprop="givenName" content="Christoph" />
    C.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Heiligman</span>,&#32;
    <meta itemprop="givenName" content="Mark" />
    M.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">HOyer</span>,&#32;
    <meta itemprop="givenName" content="Peter" />
    P.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Mhalla</span>,&#32;
    <meta itemprop="givenName" content="Mehdi" />
    M.</span>
  &#32;
    (<span itemprop="datePublished">2006</span>).
  &#32;<span itemprop="name">Quantum query complexity of some graph problems</span>.<i>
    <span itemprop="about">SIAM Journal on Computing</span>,&#32;35(6)</i>.&#32;<span itemprop="pagination">1310–1328</span>.
  <a href="https://doi.org/10.1137/050644719"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1137/050644719</a></span>




</dd>

      </div>

      <div id="qram">
        <dt>
          Giovannetti,&#32;
          Lloyd&#32;&amp;&#32;Maccone

          
          (2008)</dt>

        <dd>
          










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Giovannetti</span>,&#32;
    <meta itemprop="givenName" content="Vittorio" />
    V.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Lloyd</span>,&#32;
    <meta itemprop="givenName" content="Seth" />
    S.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Maccone</span>,&#32;
    <meta itemprop="givenName" content="Lorenzo" />
    L.</span>
  &#32;
    (<span itemprop="datePublished">2008</span>).
  &#32;<span itemprop="name">Quantum random access memory</span>.<i>
    <span itemprop="about">Phys. Rev. Lett.</span>,&#32;100</i>.&#32;<span itemprop="pagination">160501</span>.
  <a href="https://doi.org/10.1103/PhysRevLett.100.160501"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1103/PhysRevLett.100.160501</a></span>




</dd>

      </div>

      <div id="thorup_zwick_2005">
        <dt>
          Thorup&#32;&amp;&#32;Zwick

          
          (2005)</dt>

        <dd>
          










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Thorup</span>,&#32;
    <meta itemprop="givenName" content="Mikkel" />
    M.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Zwick</span>,&#32;
    <meta itemprop="givenName" content="Uri" />
    U.</span>
  &#32;
    (<span itemprop="datePublished">2005</span>).
  &#32;<span itemprop="name">Approximate distance oracles</span>.<i>
    <span itemprop="about">J. ACM</span>,&#32;52(1)</i>.&#32;<span itemprop="pagination">1–24</span>.
  <a href="https://doi.org/10.1145/1044731.1044732"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1145/1044731.1044732</a></span>




</dd>

      </div>

      <div id="apers_quantum_2019">
        <dt>
          Apers&#32;&amp;&#32;Wolf

          
          (2019)</dt>

        <dd>
          










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Apers</span>,&#32;
    <meta itemprop="givenName" content="Simon" />
    S.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Wolf</span>,&#32;
    <meta itemprop="givenName" content="Ronald" />
    R.</span>
  &#32;
    (<span itemprop="datePublished">2019</span>).
  &#32;<span itemprop="name">Quantum Speedup for Graph Sparsification, Cut Approximation and Laplacian Solving</span>.
  <a href="https://doi.org/10.48550/ARXIV.1911.07306"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.48550/ARXIV.1911.07306</a></span>




</dd>

      </div>

      <div id="batson_twice-ramanujan_2012">
        <dt>
          Batson,&#32;
          Spielman&#32;&amp;&#32;Srivastava

          
          (2012)</dt>

        <dd>
          










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Batson</span>,&#32;
    <meta itemprop="givenName" content="Joshua" />
    J.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Spielman</span>,&#32;
    <meta itemprop="givenName" content="Daniel A." />
    D.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Srivastava</span>,&#32;
    <meta itemprop="givenName" content="Nikhil" />
    N.</span>
  &#32;
    (<span itemprop="datePublished">2012</span>).
  &#32;<span itemprop="name">Twice-Ramanujan Sparsifiers</span>.<i>
    <span itemprop="about">SIAM Journal on Computing</span>,&#32;41(6)</i>.&#32;<span itemprop="pagination">1704–1721</span>.
  <a href="https://doi.org/10.1137/090772873"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1137/090772873</a></span>




</dd>

      </div>

      <div id="bollobas_modern_1998">
        <dt>
          Bollobás

          
          (1998)</dt>

        <dd>
          










<span itemscope 
      itemtype="https://schema.org/Book"
      data-type="book"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Bollobás</span>,&#32;
    <meta itemprop="givenName" content="Béla" />
    B.</span>&#32;
    (<span itemprop="datePublished">1998</span>).
  &#32;<span itemprop="name">
    <i>Modern Graph Theory</i></span>.
  <meta itemprop="contentLocation"
        value="New York, NY">&#32;
  <span itemprop="publisher"
             itemtype="http://schema.org/Organization"
             itemscope="">
    <span itemprop="name">Springer New York</span></span>.
  <a href="https://doi.org/10.1007/978-1-4612-0619-4"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1007/978-1-4612-0619-4</a></span>




</dd>

      </div>

      <div id="chen_maximum_2022">
        <dt>
          Chen,&#32;
          Kyng,&#32;
          Liu,&#32;
          Peng,&#32;
          Gutenberg&#32;&amp;&#32;Sachdeva

          
          (2022)</dt>

        <dd>
          










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Chen</span>,&#32;
    <meta itemprop="givenName" content="Li" />
    L.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Kyng</span>,&#32;
    <meta itemprop="givenName" content="Rasmus" />
    R.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Liu</span>,&#32;
    <meta itemprop="givenName" content="Yang P." />
    Y.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Peng</span>,&#32;
    <meta itemprop="givenName" content="Richard" />
    R.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Gutenberg</span>,&#32;
    <meta itemprop="givenName" content="Maximilian Probst" />
    M.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Sachdeva</span>,&#32;
    <meta itemprop="givenName" content="Sushant" />
    S.</span>
  &#32;
    (<span itemprop="datePublished">2022</span>).
  &#32;<span itemprop="name">Maximum Flow and Minimum-Cost Flow in Almost-Linear Time</span>.
  <a href="https://doi.org/10.48550/ARXIV.2203.00671"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.48550/ARXIV.2203.00671</a></span>




</dd>

      </div>

      <div id="christiani_independence_2015">
        <dt>
          Christiani,&#32;
          Pagh&#32;&amp;&#32;Thorup

          
          (2015)</dt>

        <dd>
          










<span itemscope
      itemtype="https://schema.org/CreativeWork"
      data-type="paper-conference"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Christiani</span>,&#32;
    <meta itemprop="givenName" content="Tobias" />
    T.</span>,&#32;
  <span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Pagh</span>,&#32;
    <meta itemprop="givenName" content="Rasmus" />
    R.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Thorup</span>,&#32;
    <meta itemprop="givenName" content="Mikkel" />
    M.</span>
  &#32;
    (<span itemprop="datePublished">2015</span>).
  &#32;<span itemprop="name">
    <i>From Independence to Expansion and Back Again</i></span>.
  <meta itemprop="contentLocation"
        content="Portland Oregon USA">&#32;
  <span itemprop="publisher" itemtype="http://schema.org/Organization" itemscope="">
    <span itemprop="name">ACM</span></span>.
  <a href="https://doi.org/10.1145/2746539.2746620"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1145/2746539.2746620</a></span>

</dd>

      </div>

      <div id="koutis_simple_2016">
        <dt>
          Koutis&#32;&amp;&#32;Xu

          
          (2016)</dt>

        <dd>
          










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Koutis</span>,&#32;
    <meta itemprop="givenName" content="Ioannis" />
    I.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Xu</span>,&#32;
    <meta itemprop="givenName" content="Shen Chen" />
    S.</span>
  &#32;
    (<span itemprop="datePublished">2016</span>).
  &#32;<span itemprop="name">Simple Parallel and Distributed Algorithms for Spectral Graph Sparsification</span>.<i>
    <span itemprop="about">ACM Transactions on Parallel Computing</span>,&#32;3(2)</i>.&#32;<span itemprop="pagination">1–14</span>.
  <a href="https://doi.org/10.1145/2948062"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1145/2948062</a></span>




</dd>

      </div>

      <div id="spielman_graph_2011">
        <dt>
          Spielman&#32;&amp;&#32;Srivastava

          
          (2011)</dt>

        <dd>
          










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Spielman</span>,&#32;
    <meta itemprop="givenName" content="Daniel A." />
    D.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Srivastava</span>,&#32;
    <meta itemprop="givenName" content="Nikhil" />
    N.</span>
  &#32;
    (<span itemprop="datePublished">2011</span>).
  &#32;<span itemprop="name">Graph Sparsification by Effective Resistances</span>.<i>
    <span itemprop="about">SIAM Journal on Computing</span>,&#32;40(6)</i>.&#32;<span itemprop="pagination">1913–1926</span>.
  <a href="https://doi.org/10.1137/080734029"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1137/080734029</a></span>




</dd>

      </div>

      <div id="spielman_spectral_2011">
        <dt>
          Spielman&#32;&amp;&#32;Teng

          
          (2011)</dt>

        <dd>
          










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Spielman</span>,&#32;
    <meta itemprop="givenName" content="Daniel A." />
    D.</span>&#32;&amp;&#32;<span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Teng</span>,&#32;
    <meta itemprop="givenName" content="Shang-Hua" />
    S.</span>
  &#32;
    (<span itemprop="datePublished">2011</span>).
  &#32;<span itemprop="name">Spectral Sparsification of Graphs</span>.<i>
    <span itemprop="about">SIAM Journal on Computing</span>,&#32;40(4)</i>.&#32;<span itemprop="pagination">981–1025</span>.
  <a href="https://doi.org/10.1137/08074489X"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1137/08074489X</a></span>




</dd>

      </div>

      <div id="zhandry_secure_2015">
        <dt>
          Zhandry

          
          (2015)</dt>

        <dd>
          










<span itemscope
      itemtype="https://schema.org/Article"
      data-type="article"><span itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="familyName">Zhandry</span>,&#32;
    <meta itemprop="givenName" content="Mark" />
    M.</span>
  &#32;
    (<span itemprop="datePublished">2015</span>).
  &#32;<span itemprop="name">Secure identity-based encryption in the quantum random oracle model</span>.<i>
    <span itemprop="about">International Journal of Quantum Information</span>,&#32;13(04)</i>.&#32;<span itemprop="pagination">1550014</span>.
  <a href="https://doi.org/10.1142/S0219749915500148"
     itemprop="identifier"
     itemtype="https://schema.org/URL">https://doi.org/10.1142/S0219749915500148</a></span>




</dd>

      </div>
  </dl>
</section>



<p><a href="https://thmhugo.github.io/resources/graph-sparsification.pdf"><em>get the original pdf</em></a></p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>A border edge $(i,j)$ of $\mathcal T$ is so that $i\in \mathcal T$
and $j \notin \mathcal T$.&#160;<a href="https://thmhugo.github.io" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>See for details about the QRAM model used herein.&#160;<a href="https://thmhugo.github.io" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>i.e. with $n$ edges&#160;<a href="https://thmhugo.github.io" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p>Let $\tilde{W}$ be the random variable such that
$P(\tilde{W}= \tilde{w_e}) = p_e$ and $P(\tilde{W}= {0}) = 1 - p_e$.
Then the expectation value of $\tilde{W}$ is
$\mathbb{E}(\tilde{W}) = p_e \tilde{w_e} + (1-p_e) \times 0  = p_e \tilde{w_e}$.&#160;<a href="https://thmhugo.github.io" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded></item><item><title>L-systems - Computer Graphics assignment @ Sorbonne Université</title><link>https://thmhugo.github.io/post/l-systems/</link><pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate><guid>https://thmhugo.github.io/post/l-systems/</guid><description> Foreword: In this short report, I will make a quick review of L-systems, relying on the book The algorithmic beauty of plants [@TheAB], without talking about the code implementation. The theoretical tools have not changed since the release of the book, it fully covers the state-of-the-art. I will simply explain part of its content. Finally, I have carefully chosen to explain only the parts that are the most interesting to me.</description><content:encoded><![CDATA[ <!-- <include src="https://thmhugo.github.io/../header.html"></include> -->
<p><strong>Foreword:</strong>
In this short report, I will make a quick review of L-systems, relying on the
book The algorithmic beauty of plants [@TheAB], without talking about the code
implementation. The theoretical tools have not changed since the release of the
book, it fully covers the state-of-the-art. I will simply explain part of its
content. Finally, I have carefully chosen to explain only the parts that are the
most interesting to me.</p>
<h1 id="l-systems" class="unnumbered">L-Systems</h1>
<p>This section presents the simplest class of L-systems, those which are
deterministic and context-free, called D0L-systems. One could define
L-systems as a formal way of defining developmental processes, that
suits well to organic models, and especially plant-development models.
More formally, an L-system $G$ is defined as a tuple
$\langle V, \omega, P \rangle$, where $V$ is the alphabet of symbols,
$\omega \in V^+$ is the axiom, and $P \subset V \times V^*$ is the set
of production rules, also called rewriting rules: it takes a character
$c \in V$ and returns a string $s \in V^*$. The axiom is the starting
character of the L-system, that will fully determine the iteration
process. Let $s_i$ be the result of the $i^{th}$ iteration, we define
$s_0 = \omega$. An iteration consists of the transformation
$s_i \rightarrow s_{i+1}$ defined by the successive transformations of
the characters of $s_i$ according to the production set $P$.<br>
For the sake of simplicity, if $x$ and $y$ are two string in $V^*$, then
$xy$ is the concatenation of $x$ and $y$.</p>
<h4 id="example" class="unnumbered">Example</h4>
<p>Let $G_1 = \langle V, \omega, P \rangle$, where
$V = {A,B}; \omega = A; P =
{A\rightarrow AB, B\rightarrow BA}$. Then the iterations go as
follows:</p>
<p>$$\begin{aligned}
s_0 &amp;= \omega = A \\\
s_1 &amp;= P(A) = AB \\\
s_2 &amp;= P(A)P(B) \\\
&amp;= ABBA \\\
s_3 &amp;= P(A)P(B)P(B)P(A) \\\
&amp;= ABBABAAB
\end{aligned}$$</p>
<p>It almost fully describes an L-system, we now need to interpret the
result of an iteration.</p>
<h1 id="turtle" class="unnumbered">Turtle</h1>
<p>Turtle graphics, firstly defined by the Logo programming language
[@Logo] is a descriptive way of defining computer drawings. We can hence
consider an interpretation of some characters (not necessarily all of
them) of the alphabet. This will make the turtle move on the screen, and
hence draw. For example, $F$ moves forward a step $l$, $+$ turns
clockwise the turtle of an angle $\delta$, and $-$ turns
counterclockwise the turtle of an angle $\delta$.</p>
<h4 id="example-1">Example</h4>
<p>If we let $l=1, \delta = 90$, and consider the sentence
$$FFF+FF+F+F-F-FF+FFF \ ,$$ then the turtle graphics formalism yields the
following, starting in $(0,0)$:</p>
<p>By combining the L-System formalism and the turtle graphics, one can
easily generate fractal like patterns, thanks to the recursive structure
of L-systems.</p>
<div class="figure">
<img src="https://thmhugo.github.io/img/triangle.png" alt="Matrix vector product Mtv"/>
<p class="caption" id="triangle">A triangle</p>
</div>
<p>The above figures shows a fractal-like model where each pattern
repeats itself, this comes from the recursive manner of defining an
iteration.</p>
<h1 id="more-realistic-l-systems" class="unnumbered">More realistic L-systems</h1>
<p>This definition of L-systems yields interesting and fractal-like
results, but we need to add a branching possibility in order to obtain
plant-like results. This is achieved by considering a stack of turtle
<em>states</em> and its associated operations: $\texttt{Push}$ and
$\texttt{Pop}$. Those two operations are usually represented by the
characters $[$ and $]$ respectively. This enhancement yield results
shown in <span class="autoref">fuzzy</span> and
<span class="autoref">aglae</span>.</p>
<div class="figure">
<img src="https://thmhugo.github.io/img/fuzzy.png" alt="fuzzy" >
<p class="caption" id="fuzzy">A fuzzy tree</p>
</div>
<p>The plant-like pattern appears directly, however, we will explore some
enhancement techniques in order to make those more realistic. The issue
that one faces with this kind of <em>very simple</em> L-system, is that the
plant generated by a L-system is unique, and the artificial regularity
is striking. To solve this problem, it is possible to randomize the
turtle parameters, the L-system or both.</p>
<p>Randomizing only the turtle parameters has the effect of letting the
underlying structure of the results unchanged, while randomizing the
L-system itself probabilistically changes the structure, which has the
effect of making the result more realistic. Combining the two options is
in the end the preferable solution. Such a result is shown in <span
class="autoref">ol_iterations</span>.</p>
<div class="figure">
    <img src="https://thmhugo.github.io/img/aglae.png" alt="aglae" >
    <p class="caption" id="aglae">An aglae</p>
</div>
<p>The list of species being described by L-systems grammar is vastly
increasing. Models have been made: cucumber growth [@cucumber],
sunflower [@TheAB], barley [@barley], sorghum [@sorghum].</p>
<div class="figure-table-container">
    <div class="figtbl">
        <div class="">
            <img src="https://thmhugo.github.io/img/r-tree-1.png" alt="Snow" >
        </div>
        <div class="">
            <img src="https://thmhugo.github.io/img/r-tree-2.png" alt="Forest" >
        </div>
        <div class="">
            <img src="https://thmhugo.github.io/img/r-tree-3.png" alt="Mountains" >
        </div>
    </div>
    <p class="caption" id="ol_iterations"> Three iterations of an OL-System (a random tree) </p>
</div>
<h1 id="developmental-models-of-herbaceous-plants" class="unnumbered">Developmental models of herbaceous plants</h1>
<p>In the case of self-similar structures, like trees illustrated in <span
class="autoref">fuzzy</span>, <span class="autoref">aglae</span> and <span
class="autoref">ol_iterations</span> the synthesis methods based on rewriting
rules, are fairly expressive and randomizing strategies fix the problem of
unnatural regularity. However, a more general approach is needed to model the
large variety of developmental patterns and structures found in nature,
especially, it is not possible to obtain the famous sunflower only with
0L-systems. When one observes nature, one sees that the flower development is,
although repetitive, highly controlled. For instance, in most of the cases when
a flower grows, the stem grows first, and in the end the flower appears. Partial
L-systems offer this possibility, especially for the case of single-flower
shoot.</p>
<h3 id="partial-l-systems" class="unnumbered">Partial L-systems</h3>
<p>Partial L-systems can express the vegetative growth of a plant and,
after a certain time, the production of the flower. It&rsquo;s not in essence
a new kind of L-systems, in the sense that it is completely defined by a
stochastic L-system, but arises from the interpretation of these.
Considering the example given in [@TheAB] : $$\label{eq:partial}
\begin{aligned}
\omega &amp; : a \\\
a \rightarrow &amp;
\begin{cases}
I [L] a &amp; \text{w.p. } \alpha\\\
I [L] A &amp; \text{w.p. } \beta
\end{cases} \\\
A \rightarrow &amp; K
\end{aligned}$$</p>
<p>We of course have to have $\alpha + \beta = 1$,
$\alpha, \beta \geq 0$. The flower stays in its vegetative phase as long
as the rule $a\rightarrow I[L]a$ is applied, and once the rule
$a\rightarrow I[L]A$ is selected, the shot stops and the flower appears.
It is hence possible to control the average height of the flower, by
controlling the ratio $\frac{\alpha}{\beta}$, that can be interpreted as
the average height of the result as shown in <span class="autoref">partial_iteration</span>.
Note that the number of iterations is an
upper-bound, since the rule $a\rightarrow
I[L]A$ is blocking.</p>
<div class="figure-table-container">
    <div class="figtbl">
        <div class="">
            <img src="https://thmhugo.github.io/img/f-1.png" alt="random tree 1" >
        </div>
        <div class="">
            <img src="https://thmhugo.github.io/img/f-4.png" alt="random tree 2" >
        </div>
        <div class="">
            <img src="https://thmhugo.github.io/img/f-3.png" alt="random tree 3" >
        </div>
    </div>
  <p class="caption" id="partial_iteration">Three iterations of a partial LSystems </p>
</div>
<h3 id="context-sensitive-l-systems" class="unnumbered">Context-sensitive L-systems</h3>
<p>Unlike the 0L-systems in which production rules are applied regardless
of the context, context-sensitive L-systems, apply rules depending on
the context of the character evaluated, that is, its predecessors and
successors. This effect is useful in simulating interactions between
plant parts. We thus introduce production rules of the form
$a_l &lt; a &gt; a_r \rightarrow \chi$, where the rule $a
\rightarrow \chi$ is applied if and only if $a$ is preceded by $a_l$ and
followed by $a_r$. This allows to <em>move</em> characters (see example), and
then introduce a sort of timer in the process. Systems in which we
consider only one side for the context are denoted 1L-systems, and the
one where we consider the two neighbors of a character, as the following
example, are called 2L-systems.</p>
<h4 id="example-from-theab-shortened">Example (from [@TheAB], shortened):</h4>
<p>$$\begin{aligned}
\omega &amp; : baaa \\\
b&lt;a &amp; \rightarrow b\\\
a&lt;b&gt; \emptyset &amp; \rightarrow f\\\
b &amp; \rightarrow a \\\
\end{aligned}$$</p>
<p>The first generated sentences are given below:</p>
<p>$$
baaa \Rightarrow % \quad;\quad
abaa \Rightarrow % \quad;\quad
aaba \Rightarrow % \quad;\quad
aaab \Rightarrow % \quad;\quad
aaaf \quad
$$</p>
<h4 id="note">Note:</h4>
<p>The priority of the rule application not is given by their order of
definition, but by the range of their context the broadest context is
given priority.</p>
<p>After the $4^{th}$ iteration, the character $f$ appears at the end of
the sentence, meaning that if we associate $f$ to the flower and $a$ to
the stem, then the flower appears after four iterations at the top of
the stem. It is easy, starting from this example, to infer how one can
use context-sensitive L-systems to create flower-like models.</p>
<h1 id="open-problems---miscellaneous" class="unnumbered">Open problems - Miscellaneous</h1>
<p>An interesting application of parametric context-sensitive L-systems has
been exposed by Hammel and Prusinkiewicz [@diff-eq], is the use of those
systems to express numerical solutions to initial value problems for
partial differential equation.<br>
Every 0L-system $G$ defines an obvious set of derivations $E(G)$. Those
objects, the <em>0L sequence languages</em> have been studied in
[@ROZENBERG1980195].<br>
<strong>Open problem:</strong> Given two arbitrary OL-systems $G_1$ and $G_2$, is it
possible to decide whether $E(G_1) = E(G_2)$?<br>
R. Book conjectured that the answer to the above question is positive.<br>
A locally contenative sequence is a sequence of words in which each word
can be constructed as the concatenation of previous words in the
sequence.<br>
<strong>Open problem:</strong> Is it decidable whether an arbitrary DOL-system is
locally contenative ?</p>
<p>The above problem constitutes today perhaps the most important open
problem concerning DOL systems.</p>
<h1 id="app:ldef">L-systems definitions</h1>
<h2 id="app:tri">Triangle</h2>
<p>Parameters: $$\begin{aligned}
l &amp; =10 \\\
\delta &amp; = 60 \\\
\end{aligned}$$ System: $$\begin{aligned}
\omega &amp; : A \\\
\\\
B &amp; \rightarrow -A+B+A- \\\
A &amp; \rightarrow +B-A-B+ \\\
\end{aligned}$$</p>
<h2 id="app:fuzzy">Fuzzy tree</h2>
<p>Parameters:</p>
<p>$$\begin{aligned}
l &amp; =10 \\\
\delta &amp; = 22 \\\
\end{aligned}$$</p>
<p>System:
$$\begin{aligned}
\omega &amp; : X \\\
\\\
F &amp; \rightarrow FF \\\
X &amp; \rightarrow F-[[X]+X]+F[+FX]-X \\\
\end{aligned}$$</p>
<h2 id="app:fuzzy">Randomized tree</h2>
<p>Parameters: $$\begin{aligned}
l &amp; =10 \\\
\delta &amp; = 15 \\\
\end{aligned}$$ System: $$\begin{aligned}
\omega &amp; : X \\\
\\\
F &amp; \rightarrow FF \\\
X &amp; \rightarrow \begin{cases}
F-[[XC]+XC]+[[XC]+XC]-X &amp; \text{w.p.} \frac{1}{4} \\\
F-[[XC]+XC]+[-FXC]+X &amp; \text{w.p.} \frac{1}{4} \\\
F[+XC][-XC]FX &amp; \text{w.p.} \frac{1}{4} \\\
F[+XC]F[-XC]+X &amp; \text{w.p.} \frac{1}{4} \\\
\end{cases}
\end{aligned}$$</p>
]]></content:encoded></item></channel></rss>